contributors()
demo()
help()
x = x
exit
head(iris)
names(iris)
x = iris[,-5]
y = iris$Species
kc <- kmeans(x,3)
kc
table(y,kc$cluster)
plot(x[c("Sepal.Length", "Sepal.Width")], col=kc$cluster)
points(kc$centers[,c("Sepal.Length", "Sepal.Width")], col=1:3, pch=23, cex=3)
x=3
x
clear
x<-10
x
x-<10
x <- 10
y <- 10
z <- x + y
z
x <- 10
y <- 10
z <- x-y
z
x <- 2^3
x
savehistory("~/Documents/IIT-DMML/R/Untitled.Rhistory")
x<-10
y<-20
z<-x+y # addition
z
x -< 10
x = 10
X
y<-20
y
max(2,3)
x =10
y=45
max(x,y)
objects()
max(1,2)
x <- max(2,3)
x
x = 10
log(x)
log(100)
?log
log(exp(3))
log(100, 10)
log(100)
log(100, 2)
pow() <- function() { }
pow() <- function(base, componet) { result <- base^componet return result }
pow <- function(base, componet) { result <- base^componet return result }
pow <- function(base, componet) { result <- base^componet; return result; }
pow <- function(base, exponent) { result <- base^exponent
result
}
pow(10, 2)
pow(10 2)
pow(10, 2)
# How to write a function end
# How to write a function end
# How to write a function end
#How to write a function
pow <- function(base, exponent) {
result <- base^component
return(result)
}
pow(10, 2)
#How to write a function
pow <- function(base, exponent) {
result <- base^component
return(result)
}
pow(10, 2)
# How to write a function end
x
# How to write a function end
#How to write a function
pow <- function(base, exponent) {
result <- base^component
return(result)
}
x <- pow(10, 2)
#How to write a function
pow <- function(base, exponent) {
result <- base^component
return(result)
}
x <- pow(10, 2)
x
#How to write a function
pow <- function(base, exponent) {
result <- base^component
return(result)
}
x <- pow(10, 2)
x
#How to write a function
pow <- function(base, exponent) {
result <- base^component
return(result)
}
x <- pow(10, 2)
x
#How to write a function
pow <- function(base, exponent) {
result <- base^component
return(result)
}
x <- pow(10, 2)
x
#How to write a function
pow <- function(base, exponent) {
result <- base^component
return(result)
}
x <- pow(10, 2)
x
#How to write a function
pow <- function(base, exponent) {
result <- base^component
return(result)
}
pow(10, 2)
# How to write a function end
#How to write a function
pow <- function(base, exponent) {
result <- base^component
return(result)
}
pow(10, 2)
# How to write a function end
result <- base^exponent
result <- base^exponent
#How to write a function
pow <- function(base, exponent) {
result <- base^exponent
return(result)
}
pow(10, 2)
pow(10, 2)
return(result)
pow(10, 2)
# List all the objects
objects()
ls()
#Vectors
x <- c(10,20,30,40)
x
x[1]
x[0]
x[1:4]
x[1:4]
class('semika')
class(1)
class(0.341)
class(TRUE)
x
#Arithmetic operators
x <- (22+45)/2 #Parannthesis first, Addition second, divition third
x
#Arithmetic operators
x <- (22+33)/2 #Parannthesis first, Addition second, divition third
#Arithmetic operators
x <- (22+33)/2 #Parannthesis first, Addition second, divition third
x <- (22+33)/2 #Parannthesis first, Addition second, divition third
x
#Reading a .csv file
employee <- read.csv("/employee.csv")
#Reading a .csv file
employee <- read.csv("employee.csv")
#Reading a .csv file
employee <- read.csv("/Users/admin/Documents/IIT-DMML/R/employee.csv")
employee <- read.csv("/Users/admin/Documents/IIT-DMML/R/employee.csv")
#Reading a .csv file
employee <- read.csv("/Users/admin/Documents/IIT-DMML/R/employee.csv",header=TRUE)
#Reading a .csv file
employee <- read.csv("/Users/admin/Documents/IIT-DMML/R/employee.csv", header=TRUE)
employee <- read.csv("/Users/admin/Documents/IIT-DMML/R/employee.csv", header=TRUE)
employee <- read.csv("/Users/admin/Documents/IIT-DMML/R/employee.csv", header=TRUE)
head(employee)
employee <- read.csv("employee.csv", header=TRUE)
employee <- read.csv("./employee.csv", header=TRUE)
employee <- read.csv("/employee.csv", header=TRUE)
#set workig directory
setwd("/Users/admin/Documents/IIT-DMML/R")
employee <- read.csv("employee.csv", header=TRUE)
head(employee)  # head() function will print first set of records in the file
print(employee$Name)
print(employee$Name, employee$Address)
print(employee$Name + "," + employee$Address)
print(employee$Name)
#Write CSV
?write.csv()
write.csv(employee$Name, file="employee-out.csv")
#get all software architects
employee[employee$Designation='Software Architect']
#get all software architects
employee[employee$Designation='Software Architect',]
#get all software architects
employee[employee$Designation = 'Software Architect',]
employee[employee$Designation = 'Software Architect',]
print(employee$Name)
#get all software architects
employee[employee$Designation == 'Software Architect',]
print(softwareArchitect)
#get all software architects
softwareArchitect <- employee[employee$Designation == 'Software Architect',]
print(softwareArchitect)
softwareArchitect <- employee[employee$Designation == 'Software Architect',]
print(softwareArchitect)
softwareArchitect <- employee[employee$Designation == 'Software Architect', employee$Name]
print(softwareArchitect)
softwareArchitect <- employee[employee$Designation == 'Software Architect',]
print(softwareArchitect)
#Can print only selected rows and coloumns
employee[1:2, 1:2]
employee <- read.csv("employee.csv", header=TRUE)
employee <- read.csv("/Users/admin/Documents/IIT-DMML/R/employee.csv", header=TRUE)
#Can print only selected rows and coloumns
employee[1:2, 1:2]
employee[:2, 1:2]
#Can print only selected rows and coloumns
employee[2, 1:2]
#Can print only selected rows and coloumns
employee[1:2, 1:2]
#Write CSV
?write.csv(employee)
#Can add new columbs to data set
employee$new.column <- Department
employee$new.column <- Department
#Can add new columbs to data set
employee$new.column <- NA
employee
#Can add new columbs to data set
employee$Departmet <- "Tech"
employee
print(employee)
#Also can remove columns
employee <- employee[, -6]
print(employee)
?head()
str(employee)
############# Vectors #######################
?c()
animalVector <- c('cat','dog', 'parat', 'rabit', 'dear')
print(animalVector)
#print only a one value
print(animalVector[1])
#print range of values
print(animalVector[1:3])
#can apply conditions to whole vector at once
animalVector == 'cat'
length(animalVector)
weightVector <- c(23,45,34,NA,56)
#replace missing values
weightVector
?is.na()
weightVector[is.na(weightVector)] < 45
weightVector
weightVector[is.na(weightVector)] <- 45
weightVector
weightVector <- c(23,45,34,NA_integer_,56)
weightVector[is.na(weightVector)] <- 45
weightVector
weightVector[is.na.numeric_version(weightVector)] <- 45
weightVector <- c(23,45,34,NA,56)
weightVector[is.na(weightVector)] <- 45
weightVector
#can apply function to a vector
#get the mean of weights
?mean()
mean(weightVector)
#sort vector values
?sort()
sort(animalVector)
sort(animalVector, decreasing = TRUE)
sort(animalVector, decreasing = FALSE)
class.tag < [1:3]
class.tag <- [1:3]
class.tag <- 1:3
print(class.tag)
#Can create data frames using two vectors
?data.frame
animalDataFrame <- data.frame(animalVector, weightVector)
print(animalDataFrame)
animalDataFrame <- data.frame(animalVector, weightVector, class.tag)
class.tag <- 1:5
animalDataFrame <- data.frame(animalVector, weightVector, class.tag)
print(animalDataFrame)
no <- 1:5
print(no)
animalDataFrame <- data.frame(animalVector, weightVector, no)
print(animalDataFrame)
str(animalDataFrame)
###################### Installing a Package ################
install.packages("rpart")
#Load the library
library(rpart)
help(package="rpart")
?rpart
#for loop, if, else
employee
install.packages("nueralnet")
install.packages("nueralnet")
install.packages("neuralnet")
installed.packages()[1:5,]
installed.packages()
?installed.packages()
df = data.frame(TKS, CSS, plaaced)
TKS = c(20, 10, 30, 20, 80, 30)
CSS = c(50, 56, 40, 90, 80, 60)
placed = c(1,0,0,1,1,1)
df = data.frame(TKS, CSS, plaaced)
df = data.frame(TKS, CSS, placed)
df
require(neuralnet)
require(neuralnet)
require(neuralnet)
install.packages("neuralnet")
TKS = c(20, 10, 30, 20, 80, 30)
CSS = c(50, 56, 40, 90, 80, 60)
placed = c(1,0,0,1,1,1)
df = data.frame(TKS, CSS, placed)
df
require(neuralnet)
nn = neuralnet(placed~TKS+CSS, data=df, hidden=3, act.fct = "logistic", linear.output = FALSE)
plot(nn)
nn = neuralnet(placed~TKS+CSS, data=df, hidden=4, act.fct = "logistic", linear.output = FALSE)
plot(nn)
age <- c(25, 35, 50)
salary <- c(200000, 1200000, 2000000)
df <- data.frame( "Age" = age, "Salary" = salary, stringsAsFactors = FALSE)
df
normalize <- function(x) {
return ((x - min(x)) / (max(x) - min(x)))
}
?lapply
dfNorm <- as.data.frame(lapply(df, normalize))
dfNorm
dfNorm <- as.data.frame(lapply(df[1:2], normalize))
dfNorm
dfNorm <- as.data.frame(lapply(df[2], normalize))
dfNormSalary
dfNormSalary <- as.data.frame(lapply(df[2], normalize))
dfNormSalary
dfNormSalary <- as.data.frame(lapply(df["Salary"], normalize))
dfNormSalary
new_normalize <- function(x, new_max = 1,new_min = 0) { # see how we define the max min values
a = ( ((x-min(x)) * (new_max-new_min)) / (max(x)-min(x)) ) + new_min
return(a)
}
fNorm1 <- as.data.frame(lapply(df[1:2], new_normalize))
dfNorm1
dfNorm1 <- as.data.frame(lapply(df[1:2], new_normalize))
dfNorm1
dfNormZ <- as.data.frame( scale(df[1:2] ))
dfNormZ
dfNorm4 <- as.data.frame(lapply(df, my-zScore))
my-zScore = function(x) {
return((x - mean(x)) / sd(x))
}
my-zScore = function(x) {
return((x - mean(x)) / sd(x))
}
myzScore = function(x) {
return((x - mean(x)) / sd(x))
}
dfNorm4 <- as.data.frame(lapply(df, mmyzScore))
dfNorm4
dfNorm4 <- as.data.frame(lapply(df, mmyzScore))
dfNorm4 <- as.data.frame(lapply(df, myzScore))
dfNorm4
library(datasets)
head(iris)
names(iris)
x <- iris[, -5]
x
head(x)
y <- iris$Species
y
head(y)
kc <- kmeans(x, 3)
kc
table(y,kc$cluster)
plot(x[c("Sepal.Length", "Sepal.Width")], col=kc$cluster)
points(kc$centers[,c("Sepal.Length", "Sepal.Width")], col=1:3, pch=23, cex=3)
head(iris)
set.seed(20)
irisCluster <- kmeans(iris[, 3:4], 3, nstart = 20)
irisCluster
